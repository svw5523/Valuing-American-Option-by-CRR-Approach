# Make sure we have the packages we need
import numpy as np
import pandas as pd
from sklearn.linear_model import LinearRegression # package for fitting the regression model

np.random.seed(123456789)

# approximate each path's discounted conditional expectation value by least square regression
# inspired by Longstaff-Schwartz(2001) Least Sqaure Monte Carlo approach
# a simple LSM approach for pricing American option
def least_square_monte_carlo(reps, N, k, r, sigma, dt, S_0, d, optionType="c", S=None):   
    '''
    Inspired by the Longstaff-Schwartz(2001) Least Sqaure Monte Carlo approach, this function builds a simple and generalized pricing framework for the American option by working in backwardation. 
    
    Args:
        reps: number of simulated underlying stock paths generated by Geometric Brownian Motion
        N: number of time intervals until maturity
        K: strike price for American option
        r: (annualized) continuous riskfree interest rate
        sigma: (annualized) volatility (standard deviation)
        S_0: initial stock price
        d: (annualized) continuous dividend yield
        optionType: if input is "c", solving for American call option; if input is "p", solving for American put option
        S: simulated paths generated by Geometric Brownian Motion (in numpy.array)
        
    Return:
        value: the value (cash flow) matrix of the American option given in each discretized time point (in numpy.array)
    
    '''
    
    def underlying_price(reps, N, S_0, r, sigma, dt):    

        S = S_0*np.cumprod(np.exp((r-d-(sigma**2)/2)*dt + sigma*np.sqrt(dt)*np.random.normal(0,1,(reps,N))), axis = 1) # one GBM increment

        S = np.insert(S,0,S_0, axis = 1) # add the initial stock price at inception

        return S
    
    if S is None: # if user didn't input stock price matrix
    
        S = underlying_price(reps, N, S_0, r, sigma, dt) # obtain the MC simulated underlying price
    
    value = np.zeros([reps,N+1]) # final optimal American option cash flow matrix
    
    for i in range(N,-1,-1):
        
        S_current = S[:,i] # current stock price across all paths
        
        if i == N: # determine if exercise the option at maturity
            
            if optionType == "c":
                
                value[:,i] = np.abs((S_current - k)*(S_current > k)) # store the American call option payoff if greater than 0
                
            elif optionType == "p":
            
                value[:,i] = np.abs((k - S_current)*(k > S_current)) # store the American put option payoff if greater than 0
            
        elif i == 0: # determine the discounted conditional expectation value at inception
            
            value[:,i] = np.exp(-r*dt)*value[:,i+1]
            
        else: # do backwardation until the inception
            
            if optionType == "c":
                
                in_the_money_path_loc = ((S_current - k)*(S_current > k)).nonzero() # determine the in-the-money sample paths location where immediate exercise value > 0 for American call option
            
                exercise_value = ((S_current - k)*(S_current > k))[in_the_money_path_loc] # immediately exercise value at current node for American call option
                
            elif optionType == "p":
                         
                in_the_money_path_loc = ((k - S_current)*(k > S_current)).nonzero() # determine the in-the-money sample paths location where immediate exercise value > 0 for American put option
            
                exercise_value = ((k - S_current)*(k > S_current))[in_the_money_path_loc] # immediately exercise value at current node for American put option
            
            length = len(in_the_money_path_loc[0])
            
            X = np.zeros([length,2]) # the regressor X is the in-the-money path's underlying price at current node
            
            for j in range(1,3):
                
                X[:,j-1] = np.power(S_current[in_the_money_path_loc],j) # our predictor variable X along with the basis function X^2 in LSE regression setup
            
            previous_continuation_value = value[:,i+1][in_the_money_path_loc] # the conditional expectation value in previous node
    
            Y = np.exp(-r*dt)*previous_continuation_value # our target variable Y (discounted value from continuation) in LSE regression setup
            
            try:
            
                least_square_reg_model = LinearRegression().fit(X, Y) # fit the LSE regression to estimate the discounted conditional expectation value
                
            except ValueError:
                
                raise Exception("At the time point (node)", i, "all paths are not optimal to convert into shares")
            
            predicted_conditional_exp = least_square_reg_model.predict(X) # predict the discounted (continued) conditional expectation value
        
            value[:,i] = np.exp(-r*dt)*value[:,i+1]# if do not early exercise the American option, the value of current path will just be the discounted continued option value from the previous node
            
            exercise_immediate_loc = (exercise_value > predicted_conditional_exp) # the optimal early exercise sample path location determined by LSM algorithm 
            
            optimal_loc = in_the_money_path_loc[0][exercise_immediate_loc] # optimal sample paths location at which we should early exercise
            
            optimal_cash_flow = exercise_value[exercise_immediate_loc] # optimal cash flow at current node
            
            value[optimal_loc,(i+1):] = 0 # the early exercise sample paths will have 0 value after the current time point (node) since the option can only be exercised once
            
            value[optimal_loc,i] = optimal_cash_flow # update the current optimal early exercise sample paths' value

    return value
